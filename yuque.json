[
  {
    "id": 64583239,
    "slug": "gu4y9y",
    "title": "Part 2：构造/析构/赋值运算",
    "book_id": 24421047,
    "book": {
      "id": 24421047,
      "type": "Book",
      "slug": "blog",
      "name": "Blog",
      "user_id": 198717,
      "description": "",
      "creator_id": 198717,
      "public": 0,
      "items_count": 2,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2022-01-10T17:07:07.260Z",
      "updated_at": "2022-01-10T17:07:07.000Z",
      "created_at": "2022-01-07T17:21:25.000Z",
      "namespace": "wujinzhi/blog",
      "user": {
        "id": 198717,
        "type": "User",
        "login": "wujinzhi",
        "name": "黑白",
        "description": "coding reading music",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/198717/1571636605769-avatar/69a8c954-f7b9-4212-b506-bcfff96161cc.png",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 3,
        "created_at": "2018-10-28T15:27:41.000Z",
        "updated_at": "2022-01-10T14:50:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 198717,
    "creator": {
      "id": 198717,
      "type": "User",
      "login": "wujinzhi",
      "name": "黑白",
      "description": "coding reading music",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/198717/1571636605769-avatar/69a8c954-f7b9-4212-b506-bcfff96161cc.png",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 3,
      "created_at": "2018-10-28T15:27:41.000Z",
      "updated_at": "2022-01-10T14:50:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: [Book, Effective C++]<br />tags: [C++]\n\n---\n\n​\n\n构造/析构/赋值运算<br />​\n\n<!-- more -->\n<a name=\"kCQFC\"></a>\n### 条款 05：了解 C++ 默默编写并调用哪些函数\n\n<br />\n<br />\n<br />\n<br />\n<br />​<br />\n<a name=\"EXnXA\"></a>\n### 相关链接\n\n- [《C++ Primer》](https://book.douban.com/subject/25708312/)\n- [《Effective C++》](https://book.douban.com/subject/1842426/)\n- [重述《Effective C++》](https://normaluhr.github.io/2020/12/31/Effective-C++/)\n",
    "body_draft": "categories: [Book, Effective C++]<br />tags: [C++]\n\n---\n\n​\n\n构造/析构/赋值运算<br />​\n\n<!-- more -->\n<a name=\"kCQFC\"></a>\n### 条款 05：了解 C++ 默默编写并调用哪些函数\n\n<br />\n<br />\n<br />\n<br />\n<br />​<br />\n<a name=\"EXnXA\"></a>\n### 相关链接\n\n- [《C++ Primer》](https://book.douban.com/subject/25708312/)\n- [《Effective C++》](https://book.douban.com/subject/1842426/)\n- [重述《Effective C++》](https://normaluhr.github.io/2020/12/31/Effective-C++/)\n",
    "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"u043d8617\" class=\"ne-p\"><span class=\"ne-text\">categories: [Book, Effective C++]</span></p><p id=\"ufc607fea\" class=\"ne-p\"><span class=\"ne-text\">tags: [C++]</span></p><hr id=\"MrCEq\" class=\"ne-hr\"><p id=\"u365b2ff9\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: var(--color-prettylights-syntax-comment)\"></span></p><p id=\"u6f47c87f\" class=\"ne-p\"><span class=\"ne-text\">构造/析构/赋值运算</span></p><p id=\"ua03cf13e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: var(--color-prettylights-syntax-comment)\"></span></p><p id=\"u8d806dad\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: var(--color-prettylights-syntax-comment)\">&lt;!-- more --&gt;</span></p><h3 id=\"kCQFC\"><span class=\"ne-text\">条款 05：了解 C++ 默默编写并调用哪些函数</span></h3><p id=\"u6a83b777\" class=\"ne-p\"><br></p><p id=\"u78918391\" class=\"ne-p\"><br></p><p id=\"u2baaa741\" class=\"ne-p\"><br></p><p id=\"u0558b74e\" class=\"ne-p\"><br></p><p id=\"u0c7e977c\" class=\"ne-p\"><br></p><p id=\"uff65c7fc\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: var(--color-prettylights-syntax-comment)\"></span></p><h3 id=\"EXnXA\"><span class=\"ne-text\">相关链接</span></h3><ul class=\"ne-ul\"><li id=\"u654a005c\"><a href=\"https://book.douban.com/subject/25708312/\" data-href=\"https://book.douban.com/subject/25708312/\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《C++ Primer》</span></a></li><li id=\"ubfd0e150\"><a href=\"https://book.douban.com/subject/1842426/\" data-href=\"https://book.douban.com/subject/1842426/\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《Effective C++》</span></a></li></ul><ul class=\"ne-ul\"><li id=\"u46d82df5\"><a href=\"https://normaluhr.github.io/2020/12/31/Effective-C++/\" data-href=\"https://normaluhr.github.io/2020/12/31/Effective-C++/\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">重述《Effective C++》</span></a></li></ul></div>",
    "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u043d8617\" id=\"u043d8617\"><span data-lake-id=\"u3f79ce1c\" id=\"u3f79ce1c\">categories: [Book, Effective C++]</span></p><p data-lake-id=\"ufc607fea\" id=\"ufc607fea\"><span data-lake-id=\"ub1644091\" id=\"ub1644091\">tags: [C++]</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22MrCEq%22%7D\"></card><p data-lake-id=\"u365b2ff9\" id=\"u365b2ff9\"><span data-lake-id=\"u5af2a7e1\" id=\"u5af2a7e1\" style=\"color: var(--color-prettylights-syntax-comment)\">​</span><br></p><p data-lake-id=\"u6f47c87f\" id=\"u6f47c87f\"><span data-lake-id=\"u0e041516\" id=\"u0e041516\">构造/析构/赋值运算</span></p><p data-lake-id=\"ua03cf13e\" id=\"ua03cf13e\"><span data-lake-id=\"u7bcb4cee\" id=\"u7bcb4cee\" style=\"color: var(--color-prettylights-syntax-comment)\">​</span><br></p><p data-lake-id=\"u8d806dad\" id=\"u8d806dad\"><span data-lake-id=\"uc38dc02f\" id=\"uc38dc02f\" style=\"color: var(--color-prettylights-syntax-comment)\">&lt;!-- more --&gt;</span></p><h3 data-lake-id=\"kCQFC\" id=\"kCQFC\"><span data-lake-id=\"u531ef8cb\" id=\"u531ef8cb\">条款 05：了解 C++ 默默编写并调用哪些函数</span></h3><p data-lake-id=\"u6a83b777\" id=\"u6a83b777\"><br></p><p data-lake-id=\"u78918391\" id=\"u78918391\"><br></p><p data-lake-id=\"u2baaa741\" id=\"u2baaa741\"><br></p><p data-lake-id=\"u0558b74e\" id=\"u0558b74e\"><br></p><p data-lake-id=\"u0c7e977c\" id=\"u0c7e977c\"><br></p><p data-lake-id=\"uff65c7fc\" id=\"uff65c7fc\"><span data-lake-id=\"uff7b0956\" id=\"uff7b0956\" style=\"color: var(--color-prettylights-syntax-comment)\">​</span><br></p><h3 data-lake-id=\"EXnXA\" id=\"EXnXA\"><span data-lake-id=\"u9ff0c290\" id=\"u9ff0c290\">相关链接</span></h3><ul list=\"ud514dcf9\"><li fid=\"ufc552a7a\" data-lake-id=\"u654a005c\" id=\"u654a005c\"><a href=\"https://book.douban.com/subject/25708312/\" target=\"_blank\" data-lake-id=\"u29cbf8af\" id=\"u29cbf8af\"><span data-lake-id=\"u7594e45c\" id=\"u7594e45c\">《C++ Primer》</span></a></li><li fid=\"ufc552a7a\" data-lake-id=\"ubfd0e150\" id=\"ubfd0e150\"><a href=\"https://book.douban.com/subject/1842426/\" target=\"_blank\" data-lake-id=\"u5b184d6a\" id=\"u5b184d6a\"><span data-lake-id=\"udf962637\" id=\"udf962637\">《Effective C++》</span></a></li><li fid=\"ufc552a7a\" data-lake-id=\"u46d82df5\" id=\"u46d82df5\"><a href=\"https://normaluhr.github.io/2020/12/31/Effective-C++/\" target=\"_blank\" data-lake-id=\"u0ccc7551\" id=\"u0ccc7551\"><span data-lake-id=\"uc28c8737\" id=\"uc28c8737\">重述《Effective C++》</span></a></li></ul>",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u043d8617\" id=\"u043d8617\"><span data-lake-id=\"u3f79ce1c\" id=\"u3f79ce1c\">categories: [Book, Effective C++]</span></p><p data-lake-id=\"ufc607fea\" id=\"ufc607fea\"><span data-lake-id=\"ub1644091\" id=\"ub1644091\">tags: [C++]</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22MrCEq%22%7D\"></card><p data-lake-id=\"u365b2ff9\" id=\"u365b2ff9\"><span data-lake-id=\"u5af2a7e1\" id=\"u5af2a7e1\" style=\"color: var(--color-prettylights-syntax-comment)\">​</span><br></p><p data-lake-id=\"u6f47c87f\" id=\"u6f47c87f\"><span data-lake-id=\"u0e041516\" id=\"u0e041516\">构造/析构/赋值运算</span></p><p data-lake-id=\"ua03cf13e\" id=\"ua03cf13e\"><span data-lake-id=\"u7bcb4cee\" id=\"u7bcb4cee\" style=\"color: var(--color-prettylights-syntax-comment)\">​</span><br></p><p data-lake-id=\"u8d806dad\" id=\"u8d806dad\"><span data-lake-id=\"uc38dc02f\" id=\"uc38dc02f\" style=\"color: var(--color-prettylights-syntax-comment)\">&lt;!-- more --&gt;</span></p><h3 data-lake-id=\"kCQFC\" id=\"kCQFC\"><span data-lake-id=\"u531ef8cb\" id=\"u531ef8cb\">条款 05：了解 C++ 默默编写并调用哪些函数</span></h3><p data-lake-id=\"u6a83b777\" id=\"u6a83b777\"><br></p><p data-lake-id=\"u78918391\" id=\"u78918391\"><br></p><p data-lake-id=\"u2baaa741\" id=\"u2baaa741\"><br></p><p data-lake-id=\"u0558b74e\" id=\"u0558b74e\"><br></p><p data-lake-id=\"u0c7e977c\" id=\"u0c7e977c\"><br></p><p data-lake-id=\"uff65c7fc\" id=\"uff65c7fc\"><span data-lake-id=\"uff7b0956\" id=\"uff7b0956\" style=\"color: var(--color-prettylights-syntax-comment)\">​</span><br></p><h3 data-lake-id=\"EXnXA\" id=\"EXnXA\"><span data-lake-id=\"u9ff0c290\" id=\"u9ff0c290\">相关链接</span></h3><ul list=\"ud514dcf9\"><li fid=\"ufc552a7a\" data-lake-id=\"u654a005c\" id=\"u654a005c\"><a href=\"https://book.douban.com/subject/25708312/\" target=\"_blank\" data-lake-id=\"u29cbf8af\" id=\"u29cbf8af\"><span data-lake-id=\"u7594e45c\" id=\"u7594e45c\">《C++ Primer》</span></a></li><li fid=\"ufc552a7a\" data-lake-id=\"ubfd0e150\" id=\"ubfd0e150\"><a href=\"https://book.douban.com/subject/1842426/\" target=\"_blank\" data-lake-id=\"u5b184d6a\" id=\"u5b184d6a\"><span data-lake-id=\"udf962637\" id=\"udf962637\">《Effective C++》</span></a></li><li fid=\"ufc552a7a\" data-lake-id=\"u46d82df5\" id=\"u46d82df5\"><a href=\"https://normaluhr.github.io/2020/12/31/Effective-C++/\" target=\"_blank\" data-lake-id=\"u0ccc7551\" id=\"u0ccc7551\"><span data-lake-id=\"uc28c8737\" id=\"uc28c8737\">重述《Effective C++》</span></a></li></ul>",
    "public": 1,
    "status": 1,
    "view_status": 0,
    "read_status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2022-01-10T17:07:07.000Z",
    "deleted_at": null,
    "created_at": "2022-01-10T14:50:13.000Z",
    "updated_at": "2022-01-10T17:07:07.000Z",
    "published_at": "2022-01-10T17:07:07.000Z",
    "first_published_at": "2022-01-10T14:51:42.000Z",
    "word_count": 56,
    "cover": null,
    "description": "categories: [Book, Effective C++]tags: [C++]构造/析构/赋值运算<!-- more -->条款 05：了解 C++ 默默编写并调用哪些函数相关链接《C++ Primer》《Effective C++》重述《Effective C++》",
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 64391129,
    "slug": "bc131l",
    "title": "Part 1：让自己习惯 C++",
    "book_id": 24421047,
    "book": {
      "id": 24421047,
      "type": "Book",
      "slug": "blog",
      "name": "Blog",
      "user_id": 198717,
      "description": "",
      "creator_id": 198717,
      "public": 0,
      "items_count": 2,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2022-01-10T17:16:51.900Z",
      "updated_at": "2022-01-10T17:16:51.000Z",
      "created_at": "2022-01-07T17:21:25.000Z",
      "namespace": "wujinzhi/blog",
      "user": {
        "id": 198717,
        "type": "User",
        "login": "wujinzhi",
        "name": "黑白",
        "description": "coding reading music",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/198717/1571636605769-avatar/69a8c954-f7b9-4212-b506-bcfff96161cc.png",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 3,
        "created_at": "2018-10-28T15:27:41.000Z",
        "updated_at": "2022-01-10T14:50:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 198717,
    "creator": {
      "id": 198717,
      "type": "User",
      "login": "wujinzhi",
      "name": "黑白",
      "description": "coding reading music",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/198717/1571636605769-avatar/69a8c954-f7b9-4212-b506-bcfff96161cc.png",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 3,
      "created_at": "2018-10-28T15:27:41.000Z",
      "updated_at": "2022-01-10T14:50:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: [Book, Effective C++]<br />tags: [C++]\n\n---\n\n主要讲述的是 C++ 的基础条款，其中条款 01 个人认为是入门 C++ 之前就应当阅读的，能帮助你在学习 C++ 时减少非常多的痛苦和花费的时间精力。而学会 const 的使用能避免许多麻烦，条款 04 提到的问题在我编程中真的是遇到过好几次的问题。<br /><!-- more -->\n<a name=\"CKfaN\"></a>\n### 条款 01: 视 C++ 为一个语言联邦\nC++ 支持多种范型编：过程形式、面向对象、函数式、泛型、元编程等。<br />​\n\n你总能在 C++ 中找到你需要的特性，但也正是因此不要把 C++ 当成一个语言，然后试图掌握所有特性，C++ 实际上是由以下相关语言组成的联邦：<br />​<br />\n\n- C：C++ 中的 C 部分\n- Object-Oriented C++：C++ 中的面向对象\n- Template C++：泛型编程\n- STL：Template 程序库\n\n​\n\n并非每次使用 C++ 完成编程都需要用到 C++ 的所有特性，想要使用 C++ 进行高效的编程，就要学会在需要的时候从上述相关语言中选择适合的部分。<br />​<br />\n<a name=\"WoHyi\"></a>\n### 条款 02: 尽量以 const，enum，inline 替换 #define\n\n<br />#define 不被视为语言的一部分，因此在编译器处理源码的时候可能会被预处理器移走，且记号名称没有进入记号表，这可能导致编译错误并且找不到记号名称难以调试。<br />​\n\n#define 不重视作用域，无法用于 class 专属常量。<br />​\n\n常量应当用 const 来替换 #define ，其中还有两种比较特殊说明：<br />​\n\n对于常量指针，顶层和底层 const 都需要\n```cpp\nconst char* const name = \"name\";\n```\n对于 class 常量，为保证单例，需要使用 static 修饰\n```cpp\nclass MyClass {\n\tstatic const int Count = 10;\n}\n\n// 一些编译器不允许 static 成员在声明式赋值，可以放在定义式上\nclass MyClass {\nprivate:\n\tstatic const int Count;\n}\n\nconst int MyClass::Count = 10;\n\n// 如果你需要编译期间的 class 常量，例如数组大小，可以使用 the enum hack 的方式\n// enum 的每个枚举成员都是一条常量表达式\nclass MyClass {\nprivate:\n    enum { Count = 10 };\n    int scores[Count];\n}\n```\n\n<br />形似函数的宏则应当使用 inline function 来替代，不会有函数宏的多次求值问题，并且有作用域\n```cpp\ntemplate<typename T>\ninline void fn(const &T) {\n    // do something...\n}\n```\n<a name=\"HapCP\"></a>\n### \n<a name=\"EPKJ5\"></a>\n### 条款 03: 尽可能使用 const\nconst 在语义上约束了对象，并且编译器也会强制实现这项约束并作出提示。<br />​\n\n在使用 const 需要注意区分顶层和底层 const，底层 const 指向的内容不可变，顶层 const 指针本身不可变。\n```cpp\n// 左底层，右顶层\nconst int const* count\n```\n​\n\n迭代器的 const 修饰符相当于顶层 const，如果希望迭代器指向不可变应当使用 const_iterator。\n```cpp\n// 迭代器不可变，iter++ 出错\nconst std::vector<int>::iterator iter; \n\n// 迭代器指向不可变\nstd::vector<int>::const_iterator iter;\n```\n​\n\n将操作符重载的返回值声明为 const 可以预防一些意外的赋值操作：\n```cpp\n// 有时候我们本来想比较，却意外的用了赋值\nif(a * b = c){...}\n```\n\n<br />对于一些成员函数，我们不希望它修改对象内容，应当在声明式尾部通过 const 修饰，这样的函数是 bitwise const，在该函数中无法修改对象内容。\n```cpp\nvoid fn() const;\n```\n然而对于 const 指针，编译器并不能检测出错误，原因在于在编译器看来 const 指针本身并没有改变，但我们却可以通过指针修改指向的对象。<br />​\n\n在编码过程中应该遵守的是 logical constness ，允许在逻辑合理的情况下在 const 成员函数中修改对象内容，例如 get 函数中检测并更新高速缓存。而想要实现在 const 函数中修改对象内容并通过编译，就需要使用 mutable 修饰符。\n```cpp\nclass MyClass {\npublic:\n    std::size_t length() const;\nprivate:\n    mutable std::size_t textLength;\n    mutable bool isValid;\n}\n\nstd::size_t MyClass::length() const {\n    if(!isValid) {\n    \ttextLength = newLength;\n        isValid = true;\n    }\n    \n    return textLength;\n}\n```\n对于拥有重载的成员函数，如果 const 版本和 non-const 版本除了是否有 const 修饰之外都等价，那么应当提取一个函数或者在 non-const 版本中调用 const 版本来避免代码重复，而要实现后者则是通过 const_case 进行显式的去 const 化类型转换。\n```cpp\nclass MyClass {\npublic:\n    // ...\n    const int *data() const;\n    int *data();\n\nprivate:\n    int i = 10;\n};\n\nconst int *MyClass::data() const {\n    // do something ...\n    return &i;\n}\n\n// 为了调用 const 版本的重载，需要现在在 2 处先获得 const 版本的指针\n// 然后在通过 1 处进行去 const 化。\nint *MyClass::data() {\n    return const_cast<int *>( // 1\n                &(static_cast<const MyClass&>(*this).i) // 2\n                );\n}\n```\n\n\n<a name=\"MoJwf\"></a>\n### 条款 04: 确定对象被使用前已先被初始化\n\n<br />使用未初始化的对象可能会有不确定的行为，导致程序退出，因为 C++ 并不保证自动初始化。<br />​\n\n区分赋值和初始化，在构造函数的结构体当中实际上是赋值而不是初始化，再次之前会先调用对象的 defalut 构造函数，也就是会初始化在赋值。\n```cpp\nMyClass::MyClass(const std::string &name) {\n    myName = name; // 这里是赋值，在此之前已经调用了 default 构造函数\n}\n```\n除此之外 const、references 成员变量必须初始化而不能赋值，因此应当在成员初值列表进行初始化，需要注意初始化顺序要和成员变量的声明顺序一致。\n```cpp\nMyClass::MyClass(const std::string &name,const std::string &des):\n\t:myName(name), myDes(des) // 这里进行初始化更高效\n{}\n```\n\n<br />关于初始化还有一个问题，就是“不同编译单元内定义的 non-local static”，即非函数内的 static 对象（global，namespace，class，file 内的 static），C++ 对于“不同编译单元内定义的 non-local static” 的初始化顺序没有明确定义，这将可能在未初始化前使用该对象。<br />​\n\n解决办法是用一个函数进行包装并返回 static 对象的引用，也就是我们熟悉的 Singleton 的懒汉模式，函数内 static 会在首次调用该函数进行初始化。进一步可以定义成 inline functino。<br />​<br />\n```cpp\nMyClass &getMyClass() {\n\tstatic Myclass c;\n    return c;\n}\n```\n\n<br />多线程下这样的方式依然有不确定性，解决方法是在启动阶段对这一类对象全部初始化，即 Singleton 的饿汉模式。<br />\n\n<a name=\"EXnXA\"></a>\n### 相关链接\n\n- [《C++ Primer》](https://book.douban.com/subject/25708312/)\n- [《Effective C++》](https://book.douban.com/subject/1842426/)\n",
    "body_draft": "categories: [Book, Effective C++]<br />tags: [C++]\n\n---\n\n主要讲述的是 C++ 的基础条款，其中条款 01 个人认为是入门 C++ 之前就应当阅读的，能帮助你在学习 C++ 时减少非常多的痛苦和花费的时间精力。而学会 const 的使用能避免许多麻烦，条款 04 提到的问题在我编程中真的是遇到过好几次的问题。<br /><!-- more -->\n<a name=\"CKfaN\"></a>\n### 条款 01: 视 C++ 为一个语言联邦\nC++ 支持多种范型编：过程形式、面向对象、函数式、泛型、元编程等。<br />​\n\n你总能在 C++ 中找到你需要的特性，但也正是因此不要把 C++ 当成一个语言，然后试图掌握所有特性，C++ 实际上是由以下相关语言组成的联邦：<br />​<br />\n\n- C：C++ 中的 C 部分\n- Object-Oriented C++：C++ 中的面向对象\n- Template C++：泛型编程\n- STL：Template 程序库\n\n​\n\n并非每次使用 C++ 完成编程都需要用到 C++ 的所有特性，想要使用 C++ 进行高效的编程，就要学会在需要的时候从上述相关语言中选择适合的部分。<br />​<br />\n<a name=\"WoHyi\"></a>\n### 条款 02: 尽量以 const，enum，inline 替换 #define\n\n<br />#define 不被视为语言的一部分，因此在编译器处理源码的时候可能会被预处理器移走，且记号名称没有进入记号表，这可能导致编译错误并且找不到记号名称难以调试。<br />​\n\n#define 不重视作用域，无法用于 class 专属常量。<br />​\n\n常量应当用 const 来替换 #define ，其中还有两种比较特殊说明：<br />​\n\n对于常量指针，顶层和底层 const 都需要\n```cpp\nconst char* const name = \"name\";\n```\n对于 class 常量，为保证单例，需要使用 static 修饰\n```cpp\nclass MyClass {\n\tstatic const int Count = 10;\n}\n\n// 一些编译器不允许 static 成员在声明式赋值，可以放在定义式上\nclass MyClass {\nprivate:\n\tstatic const int Count;\n}\n\nconst int MyClass::Count = 10;\n\n// 如果你需要编译期间的 class 常量，例如数组大小，可以使用 the enum hack 的方式\n// enum 的每个枚举成员都是一条常量表达式\nclass MyClass {\nprivate:\n    enum { Count = 10 };\n    int scores[Count];\n}\n```\n\n<br />形似函数的宏则应当使用 inline function 来替代，不会有函数宏的多次求值问题，并且有作用域\n```cpp\ntemplate<typename T>\ninline void fn(const &T) {\n    // do something...\n}\n```\n<a name=\"HapCP\"></a>\n### \n<a name=\"EPKJ5\"></a>\n### 条款 03: 尽可能使用 const\nconst 在语义上约束了对象，并且编译器也会强制实现这项约束并作出提示。<br />​\n\n在使用 const 需要注意区分顶层和底层 const，底层 const 指向的内容不可变，顶层 const 指针本身不可变。\n```cpp\n// 左底层，右顶层\nconst int const* count\n```\n​\n\n迭代器的 const 修饰符相当于顶层 const，如果希望迭代器指向不可变应当使用 const_iterator。\n```cpp\n// 迭代器不可变，iter++ 出错\nconst std::vector<int>::iterator iter; \n\n// 迭代器指向不可变\nstd::vector<int>::const_iterator iter;\n```\n​\n\n将操作符重载的返回值声明为 const 可以预防一些意外的赋值操作：\n```cpp\n// 有时候我们本来想比较，却意外的用了赋值\nif(a * b = c){...}\n```\n\n<br />对于一些成员函数，我们不希望它修改对象内容，应当在声明式尾部通过 const 修饰，这样的函数是 bitwise const，在该函数中无法修改对象内容。\n```cpp\nvoid fn() const;\n```\n然而对于 const 指针，编译器并不能检测出错误，原因在于在编译器看来 const 指针本身并没有改变，但我们却可以通过指针修改指向的对象。<br />​\n\n在编码过程中应该遵守的是 logical constness ，允许在逻辑合理的情况下在 const 成员函数中修改对象内容，例如 get 函数中检测并更新高速缓存。而想要实现在 const 函数中修改对象内容并通过编译，就需要使用 mutable 修饰符。\n```cpp\nclass MyClass {\npublic:\n    std::size_t length() const;\nprivate:\n    mutable std::size_t textLength;\n    mutable bool isValid;\n}\n\nstd::size_t MyClass::length() const {\n    if(!isValid) {\n    \ttextLength = newLength;\n        isValid = true;\n    }\n    \n    return textLength;\n}\n```\n对于拥有重载的成员函数，如果 const 版本和 non-const 版本除了是否有 const 修饰之外都等价，那么应当提取一个函数或者在 non-const 版本中调用 const 版本来避免代码重复，而要实现后者则是通过 const_case 进行显式的去 const 化类型转换。\n```cpp\nclass MyClass {\npublic:\n    // ...\n    const int *data() const;\n    int *data();\n\nprivate:\n    int i = 10;\n};\n\nconst int *MyClass::data() const {\n    // do something ...\n    return &i;\n}\n\n// 为了调用 const 版本的重载，需要现在在 2 处先获得 const 版本的指针\n// 然后在通过 1 处进行去 const 化。\nint *MyClass::data() {\n    return const_cast<int *>( // 1\n                &(static_cast<const MyClass&>(*this).i) // 2\n                );\n}\n```\n\n\n<a name=\"MoJwf\"></a>\n### 条款 04: 确定对象被使用前已先被初始化\n\n<br />使用未初始化的对象可能会有不确定的行为，导致程序退出，因为 C++ 并不保证自动初始化。<br />​\n\n区分赋值和初始化，在构造函数的结构体当中实际上是赋值而不是初始化，再次之前会先调用对象的 defalut 构造函数，也就是会初始化在赋值。\n```cpp\nMyClass::MyClass(const std::string &name) {\n    myName = name; // 这里是赋值，在此之前已经调用了 default 构造函数\n}\n```\n除此之外 const、references 成员变量必须初始化而不能赋值，因此应当在成员初值列表进行初始化，需要注意初始化顺序要和成员变量的声明顺序一致。\n```cpp\nMyClass::MyClass(const std::string &name,const std::string &des):\n\t:myName(name), myDes(des) // 这里进行初始化更高效\n{}\n```\n\n<br />关于初始化还有一个问题，就是“不同编译单元内定义的 non-local static”，即非函数内的 static 对象（global，namespace，class，file 内的 static），C++ 对于“不同编译单元内定义的 non-local static” 的初始化顺序没有明确定义，这将可能在未初始化前使用该对象。<br />​\n\n解决办法是用一个函数进行包装并返回 static 对象的引用，也就是我们熟悉的 Singleton 的懒汉模式，函数内 static 会在首次调用该函数进行初始化。进一步可以定义成 inline functino。<br />​<br />\n```cpp\nMyClass &getMyClass() {\n\tstatic Myclass c;\n    return c;\n}\n```\n\n<br />多线程下这样的方式依然有不确定性，解决方法是在启动阶段对这一类对象全部初始化，即 Singleton 的饿汉模式。<br />\n\n<a name=\"EXnXA\"></a>\n### 相关链接\n\n- [《C++ Primer》](https://book.douban.com/subject/25708312/)\n- [《Effective C++》](https://book.douban.com/subject/1842426/)\n",
    "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"u1d62387e\" class=\"ne-p\"><span class=\"ne-text\">categories: [Book, Effective C++]</span></p><p id=\"ufc607fea\" class=\"ne-p\"><span class=\"ne-text\">tags: [C++]</span></p><hr id=\"MrCEq\" class=\"ne-hr\"><p id=\"u9ce5e792\" class=\"ne-p\"><span class=\"ne-text\">主要讲述的是 C++ 的基础条款，其中条款 01 个人认为是入门 C++ 之前就应当阅读的，能帮助你在学习 C++ 时减少非常多的痛苦和花费的时间精力。而学会 const 的使用能避免许多麻烦，条款 04 提到的问题在我编程中真的是遇到过好几次的问题。</span></p><p id=\"u4b178b23\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: var(--color-prettylights-syntax-comment)\">&lt;!-- more --&gt;</span></p><h3 id=\"CKfaN\"><span class=\"ne-text\">条款 01: 视 C++ 为一个语言联邦</span></h3><p id=\"uee417591\" class=\"ne-p\"><span class=\"ne-text\">C++ 支持多种范型编：过程形式、面向对象、函数式、泛型、元编程等。</span></p><p id=\"uec1dbb25\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"udc2bbddd\" class=\"ne-p\"><span class=\"ne-text\">你总能在 C++ 中找到你需要的特性，但也正是因此不要把 C++ 当成一个语言，然后试图掌握所有特性，C++ 实际上是由以下相关语言组成的联邦：</span></p><p id=\"u80d6bb92\" class=\"ne-p\"><span class=\"ne-text\"></span></p><ul class=\"ne-ul\"><li id=\"u6aa6b25e\"><span class=\"ne-text\">C：C++ 中的 C 部分</span></li><li id=\"uc18a399a\"><span class=\"ne-text\">Object-Oriented C++：C++ 中的面向对象</span></li></ul><ul class=\"ne-ul\"><li id=\"u09e4aed8\"><span class=\"ne-text\">Template C++：泛型编程</span></li><li id=\"u2a84cca1\"><span class=\"ne-text\">STL：Template 程序库</span></li></ul><p id=\"u5258cc4d\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u41943553\" class=\"ne-p\"><span class=\"ne-text\">并非每次使用 C++ 完成编程都需要用到 C++ 的所有特性，想要使用 C++ 进行高效的编程，就要学会在需要的时候从上述相关语言中选择适合的部分。</span></p><p id=\"u73cee835\" class=\"ne-p\"><span class=\"ne-text\"></span></p><h3 id=\"WoHyi\"><span class=\"ne-text\">条款 02: 尽量以 const，enum，inline 替换 #define</span></h3><p id=\"u8081f5ce\" class=\"ne-p\"><br></p><p id=\"u31798228\" class=\"ne-p\"><span class=\"ne-text\">#define 不被视为语言的一部分，因此在编译器处理源码的时候可能会被预处理器移走，且记号名称没有进入记号表，这可能导致编译错误并且找不到记号名称难以调试。</span></p><p id=\"u8ce83fca\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ufb1ae502\" class=\"ne-p\"><span class=\"ne-text\">#define 不重视作用域，无法用于 class 专属常量。</span></p><p id=\"u23c62ebf\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u4ccf0c67\" class=\"ne-p\"><span class=\"ne-text\">常量应当用 const 来替换 #define ，其中还有两种比较特殊说明：</span></p><p id=\"ub326d901\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ucf4efc1d\" class=\"ne-p\"><span class=\"ne-text\">对于常量指针，顶层和底层 const 都需要</span></p><pre data-language=\"cpp\" id=\"b0SOr\" class=\"ne-codeblock language-cpp\">const char* const name = &quot;name&quot;;</pre><p id=\"ua45ab9ad\" class=\"ne-p\"><span class=\"ne-text\">对于 class 常量，为保证单例，需要使用 static 修饰</span></p><pre data-language=\"cpp\" id=\"wUjwe\" class=\"ne-codeblock language-cpp\">class MyClass {\n\tstatic const int Count = 10;\n}\n\n// 一些编译器不允许 static 成员在声明式赋值，可以放在定义式上\nclass MyClass {\nprivate:\n\tstatic const int Count;\n}\n\nconst int MyClass::Count = 10;\n\n// 如果你需要编译期间的 class 常量，例如数组大小，可以使用 the enum hack 的方式\n// enum 的每个枚举成员都是一条常量表达式\nclass MyClass {\nprivate:\n    enum { Count = 10 };\n    int scores[Count];\n}</pre><p id=\"u3cdf8034\" class=\"ne-p\"><br></p><p id=\"u3f38499e\" class=\"ne-p\"><span class=\"ne-text\">形似函数的宏则应当使用 inline function 来替代，不会有函数宏的多次求值问题，并且有作用域</span></p><pre data-language=\"cpp\" id=\"jMZiX\" class=\"ne-codeblock language-cpp\">template&lt;typename T&gt;\ninline void fn(const &amp;T) {\n    // do something...\n}</pre><h3 id=\"HapCP\"></h3><h3 id=\"EPKJ5\"><span class=\"ne-text\">条款 03: 尽可能使用 const</span></h3><p id=\"uc18461e5\" class=\"ne-p\"><span class=\"ne-text\">const 在语义上约束了对象，并且编译器也会强制实现这项约束并作出提示。</span></p><p id=\"u3e7fd461\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"uaf15c297\" class=\"ne-p\"><span class=\"ne-text\">在使用 const 需要注意区分顶层和底层 const，底层 const 指向的内容不可变，顶层 const 指针本身不可变。</span></p><pre data-language=\"cpp\" id=\"GCIh7\" class=\"ne-codeblock language-cpp\">// 左底层，右顶层\nconst int const* count</pre><p id=\"uc5794c02\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ue4a601e9\" class=\"ne-p\"><span class=\"ne-text\">迭代器的 const 修饰符相当于顶层 const，如果希望迭代器指向不可变应当使用 const_iterator。</span></p><pre data-language=\"cpp\" id=\"sGBb5\" class=\"ne-codeblock language-cpp\">// 迭代器不可变，iter++ 出错\nconst std::vector&lt;int&gt;::iterator iter; \n\n// 迭代器指向不可变\nstd::vector&lt;int&gt;::const_iterator iter;</pre><p id=\"ued82ec61\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u70d3362a\" class=\"ne-p\"><span class=\"ne-text\">将操作符重载的返回值声明为 const 可以预防一些意外的赋值操作：</span></p><pre data-language=\"cpp\" id=\"f2TJ2\" class=\"ne-codeblock language-cpp\">// 有时候我们本来想比较，却意外的用了赋值\nif(a * b = c){...}</pre><p id=\"u6342ac5f\" class=\"ne-p\"><br></p><p id=\"ufd218f7c\" class=\"ne-p\"><span class=\"ne-text\">对于一些成员函数，我们不希望它修改对象内容，应当在声明式尾部通过 const 修饰，这样的函数是 bitwise const，在该函数中无法修改对象内容。</span></p><pre data-language=\"cpp\" id=\"FUyhF\" class=\"ne-codeblock language-cpp\">void fn() const;</pre><p id=\"u6c33e13f\" class=\"ne-p\"><span class=\"ne-text\">然而对于 const 指针，编译器并不能检测出错误，原因在于在编译器看来 const 指针本身并没有改变，但我们却可以通过指针修改指向的对象。</span></p><p id=\"u5fc9a9c5\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"ub156f32f\" class=\"ne-p\"><span class=\"ne-text\">在编码过程中应该遵守的是 logical constness ，允许在逻辑合理的情况下在 const 成员函数中修改对象内容，例如 get 函数中检测并更新高速缓存。而想要实现在 const 函数中修改对象内容并通过编译，就需要使用 mutable 修饰符。</span></p><pre data-language=\"cpp\" id=\"Y1Giv\" class=\"ne-codeblock language-cpp\">class MyClass {\npublic:\n    std::size_t length() const;\nprivate:\n    mutable std::size_t textLength;\n    mutable bool isValid;\n}\n\nstd::size_t MyClass::length() const {\n    if(!isValid) {\n    \ttextLength = newLength;\n        isValid = true;\n    }\n    \n    return textLength;\n}</pre><p id=\"ue4873042\" class=\"ne-p\"><span class=\"ne-text\">对于拥有重载的成员函数，如果 const 版本和 non-const 版本除了是否有 const 修饰之外都等价，那么应当提取一个函数或者在 non-const 版本中调用 const 版本来避免代码重复，而要实现后者则是通过 const_case 进行显式的去 const 化类型转换。</span></p><pre data-language=\"cpp\" id=\"rfGtR\" class=\"ne-codeblock language-cpp\">class MyClass {\npublic:\n    // ...\n    const int *data() const;\n    int *data();\n\nprivate:\n    int i = 10;\n};\n\nconst int *MyClass::data() const {\n    // do something ...\n    return &amp;i;\n}\n\n// 为了调用 const 版本的重载，需要现在在 2 处先获得 const 版本的指针\n// 然后在通过 1 处进行去 const 化。\nint *MyClass::data() {\n    return const_cast&lt;int *&gt;( // 1\n                &amp;(static_cast&lt;const MyClass&amp;&gt;(*this).i) // 2\n                );\n}</pre><p id=\"ub107240d\" class=\"ne-p\"><br></p><h3 id=\"MoJwf\"><span class=\"ne-text\">条款 04: 确定对象被使用前已先被初始化</span></h3><p id=\"u8e01a48c\" class=\"ne-p\"><br></p><p id=\"u6b5a07f4\" class=\"ne-p\"><span class=\"ne-text\">使用未初始化的对象可能会有不确定的行为，导致程序退出，因为 C++ 并不保证自动初始化。</span></p><p id=\"ub16cd984\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u3f5410d2\" class=\"ne-p\"><span class=\"ne-text\">区分赋值和初始化，在构造函数的结构体当中实际上是赋值而不是初始化，再次之前会先调用对象的 defalut 构造函数，也就是会初始化在赋值。</span></p><pre data-language=\"cpp\" id=\"gfnfs\" class=\"ne-codeblock language-cpp\">MyClass::MyClass(const std::string &amp;name) {\n    myName = name; // 这里是赋值，在此之前已经调用了 default 构造函数\n}</pre><p id=\"ue1a120d0\" class=\"ne-p\"><span class=\"ne-text\">除此之外 const、references 成员变量必须初始化而不能赋值，因此应当在成员初值列表进行初始化，需要注意初始化顺序要和成员变量的声明顺序一致。</span></p><pre data-language=\"cpp\" id=\"LOjan\" class=\"ne-codeblock language-cpp\">MyClass::MyClass(const std::string &amp;name,const std::string &amp;des):\n\t:myName(name), myDes(des) // 这里进行初始化更高效\n{}</pre><p id=\"u5abaceec\" class=\"ne-p\"><br></p><p id=\"u4ef43cda\" class=\"ne-p\"><span class=\"ne-text\">关于初始化还有一个问题，就是“不同编译单元内定义的 non-local static”，即非函数内的 static 对象（global，namespace，class，file 内的 static），C++ 对于“不同编译单元内定义的 non-local static” 的初始化顺序没有明确定义，这将可能在未初始化前使用该对象。</span></p><p id=\"ub6a437c2\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u2d725769\" class=\"ne-p\"><span class=\"ne-text\">解决办法是用一个函数进行包装并返回 static 对象的引用，也就是我们熟悉的 Singleton 的懒汉模式，函数内 static 会在首次调用该函数进行初始化。进一步可以定义成 inline functino。</span></p><p id=\"u1d4429c5\" class=\"ne-p\"><span class=\"ne-text\"></span></p><pre data-language=\"cpp\" id=\"xTD7u\" class=\"ne-codeblock language-cpp\">MyClass &amp;getMyClass() {\n\tstatic Myclass c;\n    return c;\n}</pre><p id=\"u6b3be94b\" class=\"ne-p\"><br></p><p id=\"u3db97c51\" class=\"ne-p\"><span class=\"ne-text\">多线程下这样的方式依然有不确定性，解决方法是在启动阶段对这一类对象全部初始化，即 Singleton 的饿汉模式。</span></p><p id=\"ue498bd2d\" class=\"ne-p\"><br></p><h3 id=\"EXnXA\"><span class=\"ne-text\">相关链接</span></h3><ul class=\"ne-ul\"><li id=\"u654a005c\"><a href=\"https://book.douban.com/subject/25708312/\" data-href=\"https://book.douban.com/subject/25708312/\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《C++ Primer》</span></a></li><li id=\"ubfd0e150\"><a href=\"https://book.douban.com/subject/1842426/\" data-href=\"https://book.douban.com/subject/1842426/\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">《Effective C++》</span></a></li></ul></div>",
    "body_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u1d62387e\" id=\"u1d62387e\"><span data-lake-id=\"u3f79ce1c\" id=\"u3f79ce1c\">categories: [Book, Effective C++]</span></p><p data-lake-id=\"ufc607fea\" id=\"ufc607fea\"><span data-lake-id=\"ub1644091\" id=\"ub1644091\">tags: [C++]</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22MrCEq%22%7D\"></card><p data-lake-id=\"u9ce5e792\" id=\"u9ce5e792\"><span data-lake-id=\"u9d3bb1f5\" id=\"u9d3bb1f5\">主要讲述的是 C++ 的基础条款，其中条款 01 个人认为是入门 C++ 之前就应当阅读的，能帮助你在学习 C++ 时减少非常多的痛苦和花费的时间精力。而学会 const 的使用能避免许多麻烦，条款 04 提到的问题在我编程中真的是遇到过好几次的问题。</span></p><p data-lake-id=\"u4b178b23\" id=\"u4b178b23\"><span data-lake-id=\"uc38dc02f\" id=\"uc38dc02f\" style=\"color: var(--color-prettylights-syntax-comment)\">&lt;!-- more --&gt;</span></p><h3 data-lake-id=\"CKfaN\" id=\"CKfaN\"><span data-lake-id=\"u997ea336\" id=\"u997ea336\">条款 01: 视 C++ 为一个语言联邦</span></h3><p data-lake-id=\"uee417591\" id=\"uee417591\"><span data-lake-id=\"u91c93979\" id=\"u91c93979\">C++ 支持多种范型编：过程形式、面向对象、函数式、泛型、元编程等。</span></p><p data-lake-id=\"uec1dbb25\" id=\"uec1dbb25\"><span data-lake-id=\"u2c101f35\" id=\"u2c101f35\">​</span><br></p><p data-lake-id=\"udc2bbddd\" id=\"udc2bbddd\"><span data-lake-id=\"u9ac4878c\" id=\"u9ac4878c\">你总能在 C++ 中找到你需要的特性，但也正是因此不要把 C++ 当成一个语言，然后试图掌握所有特性，C++ 实际上是由以下相关语言组成的联邦：</span></p><p data-lake-id=\"u80d6bb92\" id=\"u80d6bb92\"><span data-lake-id=\"u63be5e31\" id=\"u63be5e31\">​</span><br></p><ul list=\"uac8cd8fa\"><li fid=\"uf71ed8b9\" data-lake-id=\"u6aa6b25e\" id=\"u6aa6b25e\"><span data-lake-id=\"ue4c22a17\" id=\"ue4c22a17\">C：C++ 中的 C 部分</span></li><li fid=\"uf71ed8b9\" data-lake-id=\"uc18a399a\" id=\"uc18a399a\"><span data-lake-id=\"u2e1dfa9d\" id=\"u2e1dfa9d\">Object-Oriented C++：C++ 中的面向对象</span></li><li fid=\"uf71ed8b9\" data-lake-id=\"u09e4aed8\" id=\"u09e4aed8\"><span data-lake-id=\"uaf231d3b\" id=\"uaf231d3b\">Template C++：泛型编程</span></li><li fid=\"uf71ed8b9\" data-lake-id=\"u2a84cca1\" id=\"u2a84cca1\"><span data-lake-id=\"uaf3798ce\" id=\"uaf3798ce\">STL：Template 程序库</span></li></ul><p data-lake-id=\"u5258cc4d\" id=\"u5258cc4d\"><span data-lake-id=\"u10ca261c\" id=\"u10ca261c\">​</span><br></p><p data-lake-id=\"u41943553\" id=\"u41943553\"><span data-lake-id=\"u320de732\" id=\"u320de732\">并非每次使用 C++ 完成编程都需要用到 C++ 的所有特性，想要使用 C++ 进行高效的编程，就要学会在需要的时候从上述相关语言中选择适合的部分。</span></p><p data-lake-id=\"u73cee835\" id=\"u73cee835\"><span data-lake-id=\"u2eb4458c\" id=\"u2eb4458c\">​</span><br></p><h3 data-lake-id=\"WoHyi\" id=\"WoHyi\"><span data-lake-id=\"u9ca03b48\" id=\"u9ca03b48\">条款 02: 尽量以 const，enum，inline 替换 #define</span></h3><p data-lake-id=\"u8081f5ce\" id=\"u8081f5ce\"><br></p><p data-lake-id=\"u31798228\" id=\"u31798228\"><span data-lake-id=\"uf1014d86\" id=\"uf1014d86\">#define 不被视为语言的一部分，因此在编译器处理源码的时候可能会被预处理器移走，且记号名称没有进入记号表，这可能导致编译错误并且找不到记号名称难以调试。</span></p><p data-lake-id=\"u8ce83fca\" id=\"u8ce83fca\"><span data-lake-id=\"ubb6395b8\" id=\"ubb6395b8\">​</span><br></p><p data-lake-id=\"ufb1ae502\" id=\"ufb1ae502\"><span data-lake-id=\"u1e2afec0\" id=\"u1e2afec0\">#define 不重视作用域，无法用于 class 专属常量。</span></p><p data-lake-id=\"u23c62ebf\" id=\"u23c62ebf\"><span data-lake-id=\"uf9538987\" id=\"uf9538987\">​</span><br></p><p data-lake-id=\"u4ccf0c67\" id=\"u4ccf0c67\"><span data-lake-id=\"u87d9ccad\" id=\"u87d9ccad\">常量应当用 const 来替换 #define ，其中还有两种比较特殊说明：</span></p><p data-lake-id=\"ub326d901\" id=\"ub326d901\"><span data-lake-id=\"u72affab3\" id=\"u72affab3\">​</span><br></p><p data-lake-id=\"ucf4efc1d\" id=\"ucf4efc1d\"><span data-lake-id=\"u220ad706\" id=\"u220ad706\">对于常量指针，顶层和底层 const 都需要</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22const%20char*%20const%20name%20%3D%20%5C%22name%5C%22%3B%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22b0SOr%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ua45ab9ad\" id=\"ua45ab9ad\"><span data-lake-id=\"ub47229ce\" id=\"ub47229ce\">对于 class 常量，为保证单例，需要使用 static 修饰</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22class%20MyClass%20%7B%5Cn%5Ctstatic%20const%20int%20Count%20%3D%2010%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E4%B8%80%E4%BA%9B%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E5%85%81%E8%AE%B8%20static%20%E6%88%90%E5%91%98%E5%9C%A8%E5%A3%B0%E6%98%8E%E5%BC%8F%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%94%BE%E5%9C%A8%E5%AE%9A%E4%B9%89%E5%BC%8F%E4%B8%8A%5Cnclass%20MyClass%20%7B%5Cnprivate%3A%5Cn%5Ctstatic%20const%20int%20Count%3B%5Cn%7D%5Cn%5Cnconst%20int%20MyClass%3A%3ACount%20%3D%2010%3B%5Cn%5Cn%2F%2F%20%E5%A6%82%E6%9E%9C%E4%BD%A0%E9%9C%80%E8%A6%81%E7%BC%96%E8%AF%91%E6%9C%9F%E9%97%B4%E7%9A%84%20class%20%E5%B8%B8%E9%87%8F%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20the%20enum%20hack%20%E7%9A%84%E6%96%B9%E5%BC%8F%5Cn%2F%2F%20enum%20%E7%9A%84%E6%AF%8F%E4%B8%AA%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98%E9%83%BD%E6%98%AF%E4%B8%80%E6%9D%A1%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%5Cnclass%20MyClass%20%7B%5Cnprivate%3A%5Cn%20%20%20%20enum%20%7B%20Count%20%3D%2010%20%7D%3B%5Cn%20%20%20%20int%20scores%5BCount%5D%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22wUjwe%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u3cdf8034\" id=\"u3cdf8034\"><br></p><p data-lake-id=\"u3f38499e\" id=\"u3f38499e\"><span data-lake-id=\"ueb5ef967\" id=\"ueb5ef967\">形似函数的宏则应当使用 inline function 来替代，不会有函数宏的多次求值问题，并且有作用域</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22template%3Ctypename%20T%3E%5Cninline%20void%20fn(const%20%26T)%20%7B%5Cn%20%20%20%20%2F%2F%20do%20something...%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22jMZiX%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h3 data-lake-id=\"HapCP\" id=\"HapCP\"><br></h3><h3 data-lake-id=\"EPKJ5\" id=\"EPKJ5\"><span data-lake-id=\"uc645c0be\" id=\"uc645c0be\">条款 03: 尽可能使用 const</span></h3><p data-lake-id=\"uc18461e5\" id=\"uc18461e5\"><span data-lake-id=\"u776bd21e\" id=\"u776bd21e\">const 在语义上约束了对象，并且编译器也会强制实现这项约束并作出提示。</span></p><p data-lake-id=\"u3e7fd461\" id=\"u3e7fd461\"><span data-lake-id=\"uf79f7c63\" id=\"uf79f7c63\">​</span><br></p><p data-lake-id=\"uaf15c297\" id=\"uaf15c297\"><span data-lake-id=\"ud2824b33\" id=\"ud2824b33\">在使用 const 需要注意区分顶层和底层 const，底层 const 指向的内容不可变，顶层 const 指针本身不可变。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22%2F%2F%20%E5%B7%A6%E5%BA%95%E5%B1%82%EF%BC%8C%E5%8F%B3%E9%A1%B6%E5%B1%82%5Cnconst%20int%20const*%20count%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22GCIh7%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"uc5794c02\" id=\"uc5794c02\"><span data-lake-id=\"u7a02be16\" id=\"u7a02be16\">​</span><br></p><p data-lake-id=\"ue4a601e9\" id=\"ue4a601e9\"><span data-lake-id=\"udea86196\" id=\"udea86196\">迭代器的 const 修饰符相当于顶层 const，如果希望迭代器指向不可变应当使用 const_iterator。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22%2F%2F%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%8Citer%2B%2B%20%E5%87%BA%E9%94%99%5Cnconst%20std%3A%3Avector%3Cint%3E%3A%3Aiterator%20iter%3B%20%5Cn%5Cn%2F%2F%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8C%87%E5%90%91%E4%B8%8D%E5%8F%AF%E5%8F%98%5Cnstd%3A%3Avector%3Cint%3E%3A%3Aconst_iterator%20iter%3B%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22sGBb5%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ued82ec61\" id=\"ued82ec61\"><span data-lake-id=\"ub67d0ae1\" id=\"ub67d0ae1\">​</span><br></p><p data-lake-id=\"u70d3362a\" id=\"u70d3362a\"><span data-lake-id=\"u3c32a42c\" id=\"u3c32a42c\">将操作符重载的返回值声明为 const 可以预防一些意外的赋值操作：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22%2F%2F%20%E6%9C%89%E6%97%B6%E5%80%99%E6%88%91%E4%BB%AC%E6%9C%AC%E6%9D%A5%E6%83%B3%E6%AF%94%E8%BE%83%EF%BC%8C%E5%8D%B4%E6%84%8F%E5%A4%96%E7%9A%84%E7%94%A8%E4%BA%86%E8%B5%8B%E5%80%BC%5Cnif(a%20*%20b%20%3D%20c)%7B...%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22f2TJ2%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u6342ac5f\" id=\"u6342ac5f\"><br></p><p data-lake-id=\"ufd218f7c\" id=\"ufd218f7c\"><span data-lake-id=\"ub15c7f56\" id=\"ub15c7f56\">对于一些成员函数，我们不希望它修改对象内容，应当在声明式尾部通过 const 修饰，这样的函数是 bitwise const，在该函数中无法修改对象内容。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22void%20fn()%20const%3B%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22FUyhF%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u6c33e13f\" id=\"u6c33e13f\"><span data-lake-id=\"ub9cca458\" id=\"ub9cca458\">然而对于 const 指针，编译器并不能检测出错误，原因在于在编译器看来 const 指针本身并没有改变，但我们却可以通过指针修改指向的对象。</span></p><p data-lake-id=\"u5fc9a9c5\" id=\"u5fc9a9c5\"><span data-lake-id=\"u7c510070\" id=\"u7c510070\">​</span><br></p><p data-lake-id=\"ub156f32f\" id=\"ub156f32f\"><span data-lake-id=\"u8b2b5ba3\" id=\"u8b2b5ba3\">在编码过程中应该遵守的是 logical constness ，允许在逻辑合理的情况下在 const 成员函数中修改对象内容，例如 get 函数中检测并更新高速缓存。而想要实现在 const 函数中修改对象内容并通过编译，就需要使用 mutable 修饰符。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22class%20MyClass%20%7B%5Cnpublic%3A%5Cn%20%20%20%20std%3A%3Asize_t%20length()%20const%3B%5Cnprivate%3A%5Cn%20%20%20%20mutable%20std%3A%3Asize_t%20textLength%3B%5Cn%20%20%20%20mutable%20bool%20isValid%3B%5Cn%7D%5Cn%5Cnstd%3A%3Asize_t%20MyClass%3A%3Alength()%20const%20%7B%5Cn%20%20%20%20if(!isValid)%20%7B%5Cn%20%20%20%20%5CttextLength%20%3D%20newLength%3B%5Cn%20%20%20%20%20%20%20%20isValid%20%3D%20true%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%5Cn%20%20%20%20return%20textLength%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22Y1Giv%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ue4873042\" id=\"ue4873042\"><span data-lake-id=\"u619fad73\" id=\"u619fad73\">对于拥有重载的成员函数，如果 const 版本和 non-const 版本除了是否有 const 修饰之外都等价，那么应当提取一个函数或者在 non-const 版本中调用 const 版本来避免代码重复，而要实现后者则是通过 const_case 进行显式的去 const 化类型转换。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22class%20MyClass%20%7B%5Cnpublic%3A%5Cn%20%20%20%20%2F%2F%20...%5Cn%20%20%20%20const%20int%20*data()%20const%3B%5Cn%20%20%20%20int%20*data()%3B%5Cn%5Cnprivate%3A%5Cn%20%20%20%20int%20i%20%3D%2010%3B%5Cn%7D%3B%5Cn%5Cnconst%20int%20*MyClass%3A%3Adata()%20const%20%7B%5Cn%20%20%20%20%2F%2F%20do%20something%20...%5Cn%20%20%20%20return%20%26i%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E4%B8%BA%E4%BA%86%E8%B0%83%E7%94%A8%20const%20%E7%89%88%E6%9C%AC%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%8C%E9%9C%80%E8%A6%81%E7%8E%B0%E5%9C%A8%E5%9C%A8%202%20%E5%A4%84%E5%85%88%E8%8E%B7%E5%BE%97%20const%20%E7%89%88%E6%9C%AC%E7%9A%84%E6%8C%87%E9%92%88%5Cn%2F%2F%20%E7%84%B6%E5%90%8E%E5%9C%A8%E9%80%9A%E8%BF%87%201%20%E5%A4%84%E8%BF%9B%E8%A1%8C%E5%8E%BB%20const%20%E5%8C%96%E3%80%82%5Cnint%20*MyClass%3A%3Adata()%20%7B%5Cn%20%20%20%20return%20const_cast%3Cint%20*%3E(%20%2F%2F%201%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26(static_cast%3Cconst%20MyClass%26%3E(*this).i)%20%2F%2F%202%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20)%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22rfGtR%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ub107240d\" id=\"ub107240d\"><br></p><h3 data-lake-id=\"MoJwf\" id=\"MoJwf\"><span data-lake-id=\"u966f81bc\" id=\"u966f81bc\">条款 04: 确定对象被使用前已先被初始化</span></h3><p data-lake-id=\"u8e01a48c\" id=\"u8e01a48c\"><br></p><p data-lake-id=\"u6b5a07f4\" id=\"u6b5a07f4\"><span data-lake-id=\"u80aeb859\" id=\"u80aeb859\">使用未初始化的对象可能会有不确定的行为，导致程序退出，因为 C++ 并不保证自动初始化。</span></p><p data-lake-id=\"ub16cd984\" id=\"ub16cd984\"><span data-lake-id=\"u6b2a30f7\" id=\"u6b2a30f7\">​</span><br></p><p data-lake-id=\"u3f5410d2\" id=\"u3f5410d2\"><span data-lake-id=\"ub965d7b5\" id=\"ub965d7b5\">区分赋值和初始化，在构造函数的结构体当中实际上是赋值而不是初始化，再次之前会先调用对象的 defalut 构造函数，也就是会初始化在赋值。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22MyClass%3A%3AMyClass(const%20std%3A%3Astring%20%26name)%20%7B%5Cn%20%20%20%20myName%20%3D%20name%3B%20%2F%2F%20%E8%BF%99%E9%87%8C%E6%98%AF%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%9C%A8%E6%AD%A4%E4%B9%8B%E5%89%8D%E5%B7%B2%E7%BB%8F%E8%B0%83%E7%94%A8%E4%BA%86%20default%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22gfnfs%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ue1a120d0\" id=\"ue1a120d0\"><span data-lake-id=\"u68072acd\" id=\"u68072acd\">除此之外 const、references 成员变量必须初始化而不能赋值，因此应当在成员初值列表进行初始化，需要注意初始化顺序要和成员变量的声明顺序一致。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22MyClass%3A%3AMyClass(const%20std%3A%3Astring%20%26name%2Cconst%20std%3A%3Astring%20%26des)%3A%5Cn%5Ct%3AmyName(name)%2C%20myDes(des)%20%2F%2F%20%E8%BF%99%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9B%B4%E9%AB%98%E6%95%88%5Cn%7B%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22LOjan%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u5abaceec\" id=\"u5abaceec\"><br></p><p data-lake-id=\"u4ef43cda\" id=\"u4ef43cda\"><span data-lake-id=\"uc7ffb737\" id=\"uc7ffb737\">关于初始化还有一个问题，就是“不同编译单元内定义的 non-local static”，即非函数内的 static 对象（global，namespace，class，file 内的 static），C++ 对于“不同编译单元内定义的 non-local static” 的初始化顺序没有明确定义，这将可能在未初始化前使用该对象。</span></p><p data-lake-id=\"ub6a437c2\" id=\"ub6a437c2\"><span data-lake-id=\"u07eb7fdf\" id=\"u07eb7fdf\">​</span><br></p><p data-lake-id=\"u2d725769\" id=\"u2d725769\"><span data-lake-id=\"u904d8846\" id=\"u904d8846\">解决办法是用一个函数进行包装并返回 static 对象的引用，也就是我们熟悉的 Singleton 的懒汉模式，函数内 static 会在首次调用该函数进行初始化。进一步可以定义成 inline functino。</span></p><p data-lake-id=\"u1d4429c5\" id=\"u1d4429c5\"><span data-lake-id=\"uf30872fe\" id=\"uf30872fe\">​</span><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22MyClass%20%26getMyClass()%20%7B%5Cn%5Ctstatic%20Myclass%20c%3B%5Cn%20%20%20%20return%20c%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22xTD7u%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u6b3be94b\" id=\"u6b3be94b\"><br></p><p data-lake-id=\"u3db97c51\" id=\"u3db97c51\"><span data-lake-id=\"u783897e7\" id=\"u783897e7\">多线程下这样的方式依然有不确定性，解决方法是在启动阶段对这一类对象全部初始化，即 Singleton 的饿汉模式。</span></p><p data-lake-id=\"ue498bd2d\" id=\"ue498bd2d\"><br></p><h3 data-lake-id=\"EXnXA\" id=\"EXnXA\"><span data-lake-id=\"u9ff0c290\" id=\"u9ff0c290\">相关链接</span></h3><ul list=\"u45d8e6d4\"><li fid=\"ufc552a7a\" data-lake-id=\"u654a005c\" id=\"u654a005c\"><a href=\"https://book.douban.com/subject/25708312/\" target=\"_blank\" data-lake-id=\"u29cbf8af\" id=\"u29cbf8af\"><span data-lake-id=\"u7594e45c\" id=\"u7594e45c\">《C++ Primer》</span></a></li><li fid=\"ufc552a7a\" data-lake-id=\"ubfd0e150\" id=\"ubfd0e150\"><a href=\"https://book.douban.com/subject/1842426/\" target=\"_blank\" data-lake-id=\"u5b184d6a\" id=\"u5b184d6a\"><span data-lake-id=\"udf962637\" id=\"udf962637\">《Effective C++》</span></a></li></ul>",
    "body_draft_lake": "<!doctype lake><meta name=\"doc-version\" content=\"1\" /><meta name=\"typography\" content=\"classic\" /><meta name=\"viewport\" content=\"adapt\" /><p data-lake-id=\"u1d62387e\" id=\"u1d62387e\"><span data-lake-id=\"u3f79ce1c\" id=\"u3f79ce1c\">categories: [Book, Effective C++]</span></p><p data-lake-id=\"ufc607fea\" id=\"ufc607fea\"><span data-lake-id=\"ub1644091\" id=\"ub1644091\">tags: [C++]</span></p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22MrCEq%22%7D\"></card><p data-lake-id=\"u9ce5e792\" id=\"u9ce5e792\"><span data-lake-id=\"u9d3bb1f5\" id=\"u9d3bb1f5\">主要讲述的是 C++ 的基础条款，其中条款 01 个人认为是入门 C++ 之前就应当阅读的，能帮助你在学习 C++ 时减少非常多的痛苦和花费的时间精力。而学会 const 的使用能避免许多麻烦，条款 04 提到的问题在我编程中真的是遇到过好几次的问题。</span></p><p data-lake-id=\"u4b178b23\" id=\"u4b178b23\"><span data-lake-id=\"uc38dc02f\" id=\"uc38dc02f\" style=\"color: var(--color-prettylights-syntax-comment)\">&lt;!-- more --&gt;</span></p><h3 data-lake-id=\"CKfaN\" id=\"CKfaN\"><span data-lake-id=\"u997ea336\" id=\"u997ea336\">条款 01: 视 C++ 为一个语言联邦</span></h3><p data-lake-id=\"uee417591\" id=\"uee417591\"><span data-lake-id=\"u91c93979\" id=\"u91c93979\">C++ 支持多种范型编：过程形式、面向对象、函数式、泛型、元编程等。</span></p><p data-lake-id=\"uec1dbb25\" id=\"uec1dbb25\"><span data-lake-id=\"u2c101f35\" id=\"u2c101f35\">​</span><br></p><p data-lake-id=\"udc2bbddd\" id=\"udc2bbddd\"><span data-lake-id=\"u9ac4878c\" id=\"u9ac4878c\">你总能在 C++ 中找到你需要的特性，但也正是因此不要把 C++ 当成一个语言，然后试图掌握所有特性，C++ 实际上是由以下相关语言组成的联邦：</span></p><p data-lake-id=\"u80d6bb92\" id=\"u80d6bb92\"><span data-lake-id=\"u63be5e31\" id=\"u63be5e31\">​</span><br></p><ul list=\"uac8cd8fa\"><li fid=\"uf71ed8b9\" data-lake-id=\"u6aa6b25e\" id=\"u6aa6b25e\"><span data-lake-id=\"ue4c22a17\" id=\"ue4c22a17\">C：C++ 中的 C 部分</span></li><li fid=\"uf71ed8b9\" data-lake-id=\"uc18a399a\" id=\"uc18a399a\"><span data-lake-id=\"u2e1dfa9d\" id=\"u2e1dfa9d\">Object-Oriented C++：C++ 中的面向对象</span></li><li fid=\"uf71ed8b9\" data-lake-id=\"u09e4aed8\" id=\"u09e4aed8\"><span data-lake-id=\"uaf231d3b\" id=\"uaf231d3b\">Template C++：泛型编程</span></li><li fid=\"uf71ed8b9\" data-lake-id=\"u2a84cca1\" id=\"u2a84cca1\"><span data-lake-id=\"uaf3798ce\" id=\"uaf3798ce\">STL：Template 程序库</span></li></ul><p data-lake-id=\"u5258cc4d\" id=\"u5258cc4d\"><span data-lake-id=\"u10ca261c\" id=\"u10ca261c\">​</span><br></p><p data-lake-id=\"u41943553\" id=\"u41943553\"><span data-lake-id=\"u320de732\" id=\"u320de732\">并非每次使用 C++ 完成编程都需要用到 C++ 的所有特性，想要使用 C++ 进行高效的编程，就要学会在需要的时候从上述相关语言中选择适合的部分。</span></p><p data-lake-id=\"u73cee835\" id=\"u73cee835\"><span data-lake-id=\"u2eb4458c\" id=\"u2eb4458c\">​</span><br></p><h3 data-lake-id=\"WoHyi\" id=\"WoHyi\"><span data-lake-id=\"u9ca03b48\" id=\"u9ca03b48\">条款 02: 尽量以 const，enum，inline 替换 #define</span></h3><p data-lake-id=\"u8081f5ce\" id=\"u8081f5ce\"><br></p><p data-lake-id=\"u31798228\" id=\"u31798228\"><span data-lake-id=\"uf1014d86\" id=\"uf1014d86\">#define 不被视为语言的一部分，因此在编译器处理源码的时候可能会被预处理器移走，且记号名称没有进入记号表，这可能导致编译错误并且找不到记号名称难以调试。</span></p><p data-lake-id=\"u8ce83fca\" id=\"u8ce83fca\"><span data-lake-id=\"ubb6395b8\" id=\"ubb6395b8\">​</span><br></p><p data-lake-id=\"ufb1ae502\" id=\"ufb1ae502\"><span data-lake-id=\"u1e2afec0\" id=\"u1e2afec0\">#define 不重视作用域，无法用于 class 专属常量。</span></p><p data-lake-id=\"u23c62ebf\" id=\"u23c62ebf\"><span data-lake-id=\"uf9538987\" id=\"uf9538987\">​</span><br></p><p data-lake-id=\"u4ccf0c67\" id=\"u4ccf0c67\"><span data-lake-id=\"u87d9ccad\" id=\"u87d9ccad\">常量应当用 const 来替换 #define ，其中还有两种比较特殊说明：</span></p><p data-lake-id=\"ub326d901\" id=\"ub326d901\"><span data-lake-id=\"u72affab3\" id=\"u72affab3\">​</span><br></p><p data-lake-id=\"ucf4efc1d\" id=\"ucf4efc1d\"><span data-lake-id=\"u220ad706\" id=\"u220ad706\">对于常量指针，顶层和底层 const 都需要</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22const%20char*%20const%20name%20%3D%20%5C%22name%5C%22%3B%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22b0SOr%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ua45ab9ad\" id=\"ua45ab9ad\"><span data-lake-id=\"ub47229ce\" id=\"ub47229ce\">对于 class 常量，为保证单例，需要使用 static 修饰</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22class%20MyClass%20%7B%5Cn%5Ctstatic%20const%20int%20Count%20%3D%2010%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E4%B8%80%E4%BA%9B%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E5%85%81%E8%AE%B8%20static%20%E6%88%90%E5%91%98%E5%9C%A8%E5%A3%B0%E6%98%8E%E5%BC%8F%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%94%BE%E5%9C%A8%E5%AE%9A%E4%B9%89%E5%BC%8F%E4%B8%8A%5Cnclass%20MyClass%20%7B%5Cnprivate%3A%5Cn%5Ctstatic%20const%20int%20Count%3B%5Cn%7D%5Cn%5Cnconst%20int%20MyClass%3A%3ACount%20%3D%2010%3B%5Cn%5Cn%2F%2F%20%E5%A6%82%E6%9E%9C%E4%BD%A0%E9%9C%80%E8%A6%81%E7%BC%96%E8%AF%91%E6%9C%9F%E9%97%B4%E7%9A%84%20class%20%E5%B8%B8%E9%87%8F%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20the%20enum%20hack%20%E7%9A%84%E6%96%B9%E5%BC%8F%5Cn%2F%2F%20enum%20%E7%9A%84%E6%AF%8F%E4%B8%AA%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98%E9%83%BD%E6%98%AF%E4%B8%80%E6%9D%A1%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%5Cnclass%20MyClass%20%7B%5Cnprivate%3A%5Cn%20%20%20%20enum%20%7B%20Count%20%3D%2010%20%7D%3B%5Cn%20%20%20%20int%20scores%5BCount%5D%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22wUjwe%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u3cdf8034\" id=\"u3cdf8034\"><br></p><p data-lake-id=\"u3f38499e\" id=\"u3f38499e\"><span data-lake-id=\"ueb5ef967\" id=\"ueb5ef967\">形似函数的宏则应当使用 inline function 来替代，不会有函数宏的多次求值问题，并且有作用域</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22template%3Ctypename%20T%3E%5Cninline%20void%20fn(const%20%26T)%20%7B%5Cn%20%20%20%20%2F%2F%20do%20something...%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22jMZiX%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><h3 data-lake-id=\"HapCP\" id=\"HapCP\"><br></h3><h3 data-lake-id=\"EPKJ5\" id=\"EPKJ5\"><span data-lake-id=\"uc645c0be\" id=\"uc645c0be\">条款 03: 尽可能使用 const</span></h3><p data-lake-id=\"uc18461e5\" id=\"uc18461e5\"><span data-lake-id=\"u776bd21e\" id=\"u776bd21e\">const 在语义上约束了对象，并且编译器也会强制实现这项约束并作出提示。</span></p><p data-lake-id=\"u3e7fd461\" id=\"u3e7fd461\"><span data-lake-id=\"uf79f7c63\" id=\"uf79f7c63\">​</span><br></p><p data-lake-id=\"uaf15c297\" id=\"uaf15c297\"><span data-lake-id=\"ud2824b33\" id=\"ud2824b33\">在使用 const 需要注意区分顶层和底层 const，底层 const 指向的内容不可变，顶层 const 指针本身不可变。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22%2F%2F%20%E5%B7%A6%E5%BA%95%E5%B1%82%EF%BC%8C%E5%8F%B3%E9%A1%B6%E5%B1%82%5Cnconst%20int%20const*%20count%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22GCIh7%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"uc5794c02\" id=\"uc5794c02\"><span data-lake-id=\"u7a02be16\" id=\"u7a02be16\">​</span><br></p><p data-lake-id=\"ue4a601e9\" id=\"ue4a601e9\"><span data-lake-id=\"udea86196\" id=\"udea86196\">迭代器的 const 修饰符相当于顶层 const，如果希望迭代器指向不可变应当使用 const_iterator。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22%2F%2F%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%8Citer%2B%2B%20%E5%87%BA%E9%94%99%5Cnconst%20std%3A%3Avector%3Cint%3E%3A%3Aiterator%20iter%3B%20%5Cn%5Cn%2F%2F%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8C%87%E5%90%91%E4%B8%8D%E5%8F%AF%E5%8F%98%5Cnstd%3A%3Avector%3Cint%3E%3A%3Aconst_iterator%20iter%3B%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22sGBb5%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ued82ec61\" id=\"ued82ec61\"><span data-lake-id=\"ub67d0ae1\" id=\"ub67d0ae1\">​</span><br></p><p data-lake-id=\"u70d3362a\" id=\"u70d3362a\"><span data-lake-id=\"u3c32a42c\" id=\"u3c32a42c\">将操作符重载的返回值声明为 const 可以预防一些意外的赋值操作：</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22%2F%2F%20%E6%9C%89%E6%97%B6%E5%80%99%E6%88%91%E4%BB%AC%E6%9C%AC%E6%9D%A5%E6%83%B3%E6%AF%94%E8%BE%83%EF%BC%8C%E5%8D%B4%E6%84%8F%E5%A4%96%E7%9A%84%E7%94%A8%E4%BA%86%E8%B5%8B%E5%80%BC%5Cnif(a%20*%20b%20%3D%20c)%7B...%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22f2TJ2%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u6342ac5f\" id=\"u6342ac5f\"><br></p><p data-lake-id=\"ufd218f7c\" id=\"ufd218f7c\"><span data-lake-id=\"ub15c7f56\" id=\"ub15c7f56\">对于一些成员函数，我们不希望它修改对象内容，应当在声明式尾部通过 const 修饰，这样的函数是 bitwise const，在该函数中无法修改对象内容。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22void%20fn()%20const%3B%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22FUyhF%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u6c33e13f\" id=\"u6c33e13f\"><span data-lake-id=\"ub9cca458\" id=\"ub9cca458\">然而对于 const 指针，编译器并不能检测出错误，原因在于在编译器看来 const 指针本身并没有改变，但我们却可以通过指针修改指向的对象。</span></p><p data-lake-id=\"u5fc9a9c5\" id=\"u5fc9a9c5\"><span data-lake-id=\"u7c510070\" id=\"u7c510070\">​</span><br></p><p data-lake-id=\"ub156f32f\" id=\"ub156f32f\"><span data-lake-id=\"u8b2b5ba3\" id=\"u8b2b5ba3\">在编码过程中应该遵守的是 logical constness ，允许在逻辑合理的情况下在 const 成员函数中修改对象内容，例如 get 函数中检测并更新高速缓存。而想要实现在 const 函数中修改对象内容并通过编译，就需要使用 mutable 修饰符。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22class%20MyClass%20%7B%5Cnpublic%3A%5Cn%20%20%20%20std%3A%3Asize_t%20length()%20const%3B%5Cnprivate%3A%5Cn%20%20%20%20mutable%20std%3A%3Asize_t%20textLength%3B%5Cn%20%20%20%20mutable%20bool%20isValid%3B%5Cn%7D%5Cn%5Cnstd%3A%3Asize_t%20MyClass%3A%3Alength()%20const%20%7B%5Cn%20%20%20%20if(!isValid)%20%7B%5Cn%20%20%20%20%5CttextLength%20%3D%20newLength%3B%5Cn%20%20%20%20%20%20%20%20isValid%20%3D%20true%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%5Cn%20%20%20%20return%20textLength%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22Y1Giv%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ue4873042\" id=\"ue4873042\"><span data-lake-id=\"u619fad73\" id=\"u619fad73\">对于拥有重载的成员函数，如果 const 版本和 non-const 版本除了是否有 const 修饰之外都等价，那么应当提取一个函数或者在 non-const 版本中调用 const 版本来避免代码重复，而要实现后者则是通过 const_case 进行显式的去 const 化类型转换。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22class%20MyClass%20%7B%5Cnpublic%3A%5Cn%20%20%20%20%2F%2F%20...%5Cn%20%20%20%20const%20int%20*data()%20const%3B%5Cn%20%20%20%20int%20*data()%3B%5Cn%5Cnprivate%3A%5Cn%20%20%20%20int%20i%20%3D%2010%3B%5Cn%7D%3B%5Cn%5Cnconst%20int%20*MyClass%3A%3Adata()%20const%20%7B%5Cn%20%20%20%20%2F%2F%20do%20something%20...%5Cn%20%20%20%20return%20%26i%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E4%B8%BA%E4%BA%86%E8%B0%83%E7%94%A8%20const%20%E7%89%88%E6%9C%AC%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%8C%E9%9C%80%E8%A6%81%E7%8E%B0%E5%9C%A8%E5%9C%A8%202%20%E5%A4%84%E5%85%88%E8%8E%B7%E5%BE%97%20const%20%E7%89%88%E6%9C%AC%E7%9A%84%E6%8C%87%E9%92%88%5Cn%2F%2F%20%E7%84%B6%E5%90%8E%E5%9C%A8%E9%80%9A%E8%BF%87%201%20%E5%A4%84%E8%BF%9B%E8%A1%8C%E5%8E%BB%20const%20%E5%8C%96%E3%80%82%5Cnint%20*MyClass%3A%3Adata()%20%7B%5Cn%20%20%20%20return%20const_cast%3Cint%20*%3E(%20%2F%2F%201%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26(static_cast%3Cconst%20MyClass%26%3E(*this).i)%20%2F%2F%202%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20)%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22rfGtR%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ub107240d\" id=\"ub107240d\"><br></p><h3 data-lake-id=\"MoJwf\" id=\"MoJwf\"><span data-lake-id=\"u966f81bc\" id=\"u966f81bc\">条款 04: 确定对象被使用前已先被初始化</span></h3><p data-lake-id=\"u8e01a48c\" id=\"u8e01a48c\"><br></p><p data-lake-id=\"u6b5a07f4\" id=\"u6b5a07f4\"><span data-lake-id=\"u80aeb859\" id=\"u80aeb859\">使用未初始化的对象可能会有不确定的行为，导致程序退出，因为 C++ 并不保证自动初始化。</span></p><p data-lake-id=\"ub16cd984\" id=\"ub16cd984\"><span data-lake-id=\"u6b2a30f7\" id=\"u6b2a30f7\">​</span><br></p><p data-lake-id=\"u3f5410d2\" id=\"u3f5410d2\"><span data-lake-id=\"ub965d7b5\" id=\"ub965d7b5\">区分赋值和初始化，在构造函数的结构体当中实际上是赋值而不是初始化，再次之前会先调用对象的 defalut 构造函数，也就是会初始化在赋值。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22MyClass%3A%3AMyClass(const%20std%3A%3Astring%20%26name)%20%7B%5Cn%20%20%20%20myName%20%3D%20name%3B%20%2F%2F%20%E8%BF%99%E9%87%8C%E6%98%AF%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%9C%A8%E6%AD%A4%E4%B9%8B%E5%89%8D%E5%B7%B2%E7%BB%8F%E8%B0%83%E7%94%A8%E4%BA%86%20default%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22gfnfs%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"ue1a120d0\" id=\"ue1a120d0\"><span data-lake-id=\"u68072acd\" id=\"u68072acd\">除此之外 const、references 成员变量必须初始化而不能赋值，因此应当在成员初值列表进行初始化，需要注意初始化顺序要和成员变量的声明顺序一致。</span></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22MyClass%3A%3AMyClass(const%20std%3A%3Astring%20%26name%2Cconst%20std%3A%3Astring%20%26des)%3A%5Cn%5Ct%3AmyName(name)%2C%20myDes(des)%20%2F%2F%20%E8%BF%99%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9B%B4%E9%AB%98%E6%95%88%5Cn%7B%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22LOjan%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u5abaceec\" id=\"u5abaceec\"><br></p><p data-lake-id=\"u4ef43cda\" id=\"u4ef43cda\"><span data-lake-id=\"uc7ffb737\" id=\"uc7ffb737\">关于初始化还有一个问题，就是“不同编译单元内定义的 non-local static”，即非函数内的 static 对象（global，namespace，class，file 内的 static），C++ 对于“不同编译单元内定义的 non-local static” 的初始化顺序没有明确定义，这将可能在未初始化前使用该对象。</span></p><p data-lake-id=\"ub6a437c2\" id=\"ub6a437c2\"><span data-lake-id=\"u07eb7fdf\" id=\"u07eb7fdf\">​</span><br></p><p data-lake-id=\"u2d725769\" id=\"u2d725769\"><span data-lake-id=\"u904d8846\" id=\"u904d8846\">解决办法是用一个函数进行包装并返回 static 对象的引用，也就是我们熟悉的 Singleton 的懒汉模式，函数内 static 会在首次调用该函数进行初始化。进一步可以定义成 inline functino。</span></p><p data-lake-id=\"u1d4429c5\" id=\"u1d4429c5\"><span data-lake-id=\"uf30872fe\" id=\"uf30872fe\">​</span><br></p><card type=\"inline\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22cpp%22%2C%22code%22%3A%22MyClass%20%26getMyClass()%20%7B%5Cn%5Ctstatic%20Myclass%20c%3B%5Cn%20%20%20%20return%20c%3B%5Cn%7D%22%2C%22autoWrap%22%3Afalse%2C%22theme%22%3A%22default%22%2C%22__spacing%22%3A%22both%22%2C%22heightLimit%22%3Atrue%2C%22id%22%3A%22xTD7u%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%7D\"></card><p data-lake-id=\"u6b3be94b\" id=\"u6b3be94b\"><br></p><p data-lake-id=\"u3db97c51\" id=\"u3db97c51\"><span data-lake-id=\"u783897e7\" id=\"u783897e7\">多线程下这样的方式依然有不确定性，解决方法是在启动阶段对这一类对象全部初始化，即 Singleton 的饿汉模式。</span></p><p data-lake-id=\"ue498bd2d\" id=\"ue498bd2d\"><br></p><h3 data-lake-id=\"EXnXA\" id=\"EXnXA\"><span data-lake-id=\"u9ff0c290\" id=\"u9ff0c290\">相关链接</span></h3><ul list=\"u45d8e6d4\"><li fid=\"ufc552a7a\" data-lake-id=\"u654a005c\" id=\"u654a005c\"><a href=\"https://book.douban.com/subject/25708312/\" target=\"_blank\" data-lake-id=\"u29cbf8af\" id=\"u29cbf8af\"><span data-lake-id=\"u7594e45c\" id=\"u7594e45c\">《C++ Primer》</span></a></li><li fid=\"ufc552a7a\" data-lake-id=\"ubfd0e150\" id=\"ubfd0e150\"><a href=\"https://book.douban.com/subject/1842426/\" target=\"_blank\" data-lake-id=\"u5b184d6a\" id=\"u5b184d6a\"><span data-lake-id=\"udf962637\" id=\"udf962637\">《Effective C++》</span></a></li></ul>",
    "public": 1,
    "status": 1,
    "view_status": 0,
    "read_status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2022-01-10T17:16:51.000Z",
    "deleted_at": null,
    "created_at": "2022-01-07T17:29:34.000Z",
    "updated_at": "2022-01-10T17:16:51.000Z",
    "published_at": "2022-01-10T17:16:51.000Z",
    "first_published_at": "2022-01-07T17:30:58.000Z",
    "word_count": 1721,
    "cover": null,
    "description": "categories: [Book, Effective C++]tags: [C++]主要讲述的是 C++ 的基础条款，其中条款 01 个人认为是入门 C++ 之前就应当阅读的，能帮助你在学习 C++ 时减少非常多的痛苦和花费的时间精力。而学会 const 的使用能避免许多麻烦，条款 04 ...",
    "custom_description": null,
    "hits": 0,
    "_serializer": "v2.doc_detail"
  }
]